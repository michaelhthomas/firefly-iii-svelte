/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v2.0.10
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2023-10-15T12:13:25+00:00  Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that. 
 *
 * The version of the OpenAPI document: 2.0.10
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BadRequest,
  InternalException,
  NotFound,
  RuleArray,
  RuleGroupArray,
  RuleGroupSingle,
  RuleGroupStore,
  RuleGroupUpdate,
  TransactionArray,
  Unauthenticated,
  ValidationError,
} from '../models/index';
import {
    BadRequestFromJSON,
    BadRequestToJSON,
    InternalExceptionFromJSON,
    InternalExceptionToJSON,
    NotFoundFromJSON,
    NotFoundToJSON,
    RuleArrayFromJSON,
    RuleArrayToJSON,
    RuleGroupArrayFromJSON,
    RuleGroupArrayToJSON,
    RuleGroupSingleFromJSON,
    RuleGroupSingleToJSON,
    RuleGroupStoreFromJSON,
    RuleGroupStoreToJSON,
    RuleGroupUpdateFromJSON,
    RuleGroupUpdateToJSON,
    TransactionArrayFromJSON,
    TransactionArrayToJSON,
    UnauthenticatedFromJSON,
    UnauthenticatedToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models/index';

export interface DeleteRuleGroupRequest {
    id: string;
    xTraceId?: string;
}

export interface FireRuleGroupRequest {
    id: string;
    xTraceId?: string;
    start?: Date;
    end?: Date;
    accounts?: Array<number>;
}

export interface GetRuleGroupRequest {
    id: string;
    xTraceId?: string;
}

export interface ListRuleByGroupRequest {
    id: string;
    xTraceId?: string;
    limit?: number;
    page?: number;
}

export interface ListRuleGroupRequest {
    xTraceId?: string;
    limit?: number;
    page?: number;
}

export interface StoreRuleGroupRequest {
    ruleGroupStore: RuleGroupStore;
    xTraceId?: string;
}

export interface TestRuleGroupRequest {
    id: string;
    xTraceId?: string;
    limit?: number;
    page?: number;
    start?: Date;
    end?: Date;
    searchLimit?: number;
    triggeredLimit?: number;
    accounts?: Array<number>;
}

export interface UpdateRuleGroupRequest {
    id: string;
    ruleGroupUpdate: RuleGroupUpdate;
    xTraceId?: string;
}

/**
 * 
 */
export class RuleGroupsApi extends runtime.BaseAPI {

    /**
     * Delete a rule group.
     * Delete a rule group.
     */
    async deleteRuleGroupRaw(requestParameters: DeleteRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteRuleGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/rule-groups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a rule group.
     * Delete a rule group.
     */
    async deleteRuleGroup(requestParameters: DeleteRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRuleGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
     * Fire the rule group on your transactions.
     */
    async fireRuleGroupRaw(requestParameters: FireRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling fireRuleGroup.');
        }

        const queryParameters: any = {};

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = (requestParameters.start as any).toISOString().substring(0,10);
        }

        if (requestParameters.end !== undefined) {
            queryParameters['end'] = (requestParameters.end as any).toISOString().substring(0,10);
        }

        if (requestParameters.accounts) {
            queryParameters['accounts[]'] = requestParameters.accounts;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/rule-groups/{id}/trigger`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Fire the rule group on your transactions. Changes will be made by the rules in the rule group! Limit the result if you want to.
     * Fire the rule group on your transactions.
     */
    async fireRuleGroup(requestParameters: FireRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.fireRuleGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Get a single rule group. This does not include the rules. For that, see below.
     * Get a single rule group.
     */
    async getRuleGroupRaw(requestParameters: GetRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RuleGroupSingle>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getRuleGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/rule-groups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RuleGroupSingleFromJSON(jsonValue));
    }

    /**
     * Get a single rule group. This does not include the rules. For that, see below.
     * Get a single rule group.
     */
    async getRuleGroup(requestParameters: GetRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RuleGroupSingle> {
        const response = await this.getRuleGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List rules in this rule group.
     * List rules in this rule group.
     */
    async listRuleByGroupRaw(requestParameters: ListRuleByGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RuleArray>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling listRuleByGroup.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/rule-groups/{id}/rules`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RuleArrayFromJSON(jsonValue));
    }

    /**
     * List rules in this rule group.
     * List rules in this rule group.
     */
    async listRuleByGroup(requestParameters: ListRuleByGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RuleArray> {
        const response = await this.listRuleByGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all rule groups.
     * List all rule groups.
     */
    async listRuleGroupRaw(requestParameters: ListRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RuleGroupArray>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/rule-groups`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RuleGroupArrayFromJSON(jsonValue));
    }

    /**
     * List all rule groups.
     * List all rule groups.
     */
    async listRuleGroup(requestParameters: ListRuleGroupRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RuleGroupArray> {
        const response = await this.listRuleGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
     * Store a new rule group.
     */
    async storeRuleGroupRaw(requestParameters: StoreRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RuleGroupSingle>> {
        if (requestParameters.ruleGroupStore === null || requestParameters.ruleGroupStore === undefined) {
            throw new runtime.RequiredError('ruleGroupStore','Required parameter requestParameters.ruleGroupStore was null or undefined when calling storeRuleGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/rule-groups`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RuleGroupStoreToJSON(requestParameters.ruleGroupStore),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RuleGroupSingleFromJSON(jsonValue));
    }

    /**
     * Creates a new rule group. The data required can be submitted as a JSON body or as a list of parameters.
     * Store a new rule group.
     */
    async storeRuleGroup(requestParameters: StoreRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RuleGroupSingle> {
        const response = await this.storeRuleGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
     * Test which transactions would be hit by the rule group. No changes will be made.
     */
    async testRuleGroupRaw(requestParameters: TestRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TransactionArray>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling testRuleGroup.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = (requestParameters.start as any).toISOString().substring(0,10);
        }

        if (requestParameters.end !== undefined) {
            queryParameters['end'] = (requestParameters.end as any).toISOString().substring(0,10);
        }

        if (requestParameters.searchLimit !== undefined) {
            queryParameters['search_limit'] = requestParameters.searchLimit;
        }

        if (requestParameters.triggeredLimit !== undefined) {
            queryParameters['triggered_limit'] = requestParameters.triggeredLimit;
        }

        if (requestParameters.accounts) {
            queryParameters['accounts[]'] = requestParameters.accounts;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/rule-groups/{id}/test`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TransactionArrayFromJSON(jsonValue));
    }

    /**
     * Test which transactions would be hit by the rule group. No changes will be made. Limit the result if you want to.
     * Test which transactions would be hit by the rule group. No changes will be made.
     */
    async testRuleGroup(requestParameters: TestRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TransactionArray> {
        const response = await this.testRuleGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update existing rule group.
     * Update existing rule group.
     */
    async updateRuleGroupRaw(requestParameters: UpdateRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RuleGroupSingle>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateRuleGroup.');
        }

        if (requestParameters.ruleGroupUpdate === null || requestParameters.ruleGroupUpdate === undefined) {
            throw new runtime.RequiredError('ruleGroupUpdate','Required parameter requestParameters.ruleGroupUpdate was null or undefined when calling updateRuleGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/rule-groups/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RuleGroupUpdateToJSON(requestParameters.ruleGroupUpdate),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RuleGroupSingleFromJSON(jsonValue));
    }

    /**
     * Update existing rule group.
     * Update existing rule group.
     */
    async updateRuleGroup(requestParameters: UpdateRuleGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RuleGroupSingle> {
        const response = await this.updateRuleGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
