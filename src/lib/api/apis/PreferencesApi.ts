/* tslint:disable */
/* eslint-disable */
/**
 * Firefly III API v2.0.10
 * This is the documentation of the Firefly III API. You can find accompanying documentation on the website of Firefly III itself (see below). Please report any bugs or issues. You may use the \"Authorize\" button to try the API below. This file was last generated on 2023-10-15T12:13:25+00:00  Please keep in mind that the demo site does not accept requests from curl, colly, wget, etc. You must use a browser or a tool like Postman to make requests. Too many script kiddies out there, sorry about that. 
 *
 * The version of the OpenAPI document: 2.0.10
 * Contact: james@firefly-iii.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BadRequest,
  InternalException,
  NotFound,
  Preference,
  PreferenceArray,
  PreferenceSingle,
  PreferenceUpdate,
  Unauthenticated,
  ValidationError,
} from '../models/index';
import {
    BadRequestFromJSON,
    BadRequestToJSON,
    InternalExceptionFromJSON,
    InternalExceptionToJSON,
    NotFoundFromJSON,
    NotFoundToJSON,
    PreferenceFromJSON,
    PreferenceToJSON,
    PreferenceArrayFromJSON,
    PreferenceArrayToJSON,
    PreferenceSingleFromJSON,
    PreferenceSingleToJSON,
    PreferenceUpdateFromJSON,
    PreferenceUpdateToJSON,
    UnauthenticatedFromJSON,
    UnauthenticatedToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models/index';

export interface GetPreferenceRequest {
    name: string;
    xTraceId?: string;
}

export interface ListPreferenceRequest {
    xTraceId?: string;
    limit?: number;
    page?: number;
}

export interface StorePreferenceRequest {
    preference: Preference;
    xTraceId?: string;
}

export interface UpdatePreferenceRequest {
    name: string;
    preferenceUpdate: PreferenceUpdate;
    xTraceId?: string;
}

/**
 * 
 */
export class PreferencesApi extends runtime.BaseAPI {

    /**
     * Return a single preference and the value.
     * Return a single preference.
     */
    async getPreferenceRaw(requestParameters: GetPreferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PreferenceSingle>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getPreference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/preferences/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PreferenceSingleFromJSON(jsonValue));
    }

    /**
     * Return a single preference and the value.
     * Return a single preference.
     */
    async getPreference(requestParameters: GetPreferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PreferenceSingle> {
        const response = await this.getPreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all of the preferences of the user.
     * List all users preferences.
     */
    async listPreferenceRaw(requestParameters: ListPreferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PreferenceArray>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/preferences`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PreferenceArrayFromJSON(jsonValue));
    }

    /**
     * List all of the preferences of the user.
     * List all users preferences.
     */
    async listPreference(requestParameters: ListPreferenceRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PreferenceArray> {
        const response = await this.listPreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
     * Store a new preference for this user.
     */
    async storePreferenceRaw(requestParameters: StorePreferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PreferenceSingle>> {
        if (requestParameters.preference === null || requestParameters.preference === undefined) {
            throw new runtime.RequiredError('preference','Required parameter requestParameters.preference was null or undefined when calling storePreference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/preferences`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PreferenceToJSON(requestParameters.preference),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PreferenceSingleFromJSON(jsonValue));
    }

    /**
     * This endpoint creates a new preference. The name and data are free-format, and entirely up to you. If the preference is not used in Firefly III itself it may not be configurable through the user interface, but you can use this endpoint to persist custom data for your own app.
     * Store a new preference for this user.
     */
    async storePreference(requestParameters: StorePreferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PreferenceSingle> {
        const response = await this.storePreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a user\'s preference.
     * Update preference
     */
    async updatePreferenceRaw(requestParameters: UpdatePreferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PreferenceSingle>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling updatePreference.');
        }

        if (requestParameters.preferenceUpdate === null || requestParameters.preferenceUpdate === undefined) {
            throw new runtime.RequiredError('preferenceUpdate','Required parameter requestParameters.preferenceUpdate was null or undefined when calling updatePreference.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xTraceId !== undefined && requestParameters.xTraceId !== null) {
            headerParameters['X-Trace-Id'] = String(requestParameters.xTraceId);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("firefly_iii_auth", []);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("local_bearer_auth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/preferences/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PreferenceUpdateToJSON(requestParameters.preferenceUpdate),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PreferenceSingleFromJSON(jsonValue));
    }

    /**
     * Update a user\'s preference.
     * Update preference
     */
    async updatePreference(requestParameters: UpdatePreferenceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PreferenceSingle> {
        const response = await this.updatePreferenceRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
